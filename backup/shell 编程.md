# 一、运算符

## 1、算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

|运算符|说明|举例|
| :----: | :-------------------------------------------: | :------------------------: |
|+|加法|`expr $a + $b` 结果为 30。|
|-|减法|`expr $a - $b` 结果为 -10。|
|*|乘法|`expr $a \* $b` 结果为  200。|
|/|除法|`expr $b / $a` 结果为 2。|
|%|取余|`expr $b % $a` 结果为 0。|
|=|赋值|a=$b 把变量 b 的值赋给 a。|
|==|相等。用于比较两个数字，相同则返回 true。|[ $a ==$b ] 返回 false。|
|!=|不相等。用于比较两个数字，不相同则返回 true。|[ $a !=$b ] 返回 true。|

**注意：** 条件表达式要放在方括号之间，并且要有空格，例如:  **[**​**$a==$**​**b]**  是错误的，必须写成  **[ **​**$a ==$**​**b ]** 。

- 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；
- if...then...fi 是条件语句，后续将会讲解。
- 在 MAC 中 shell 的 expr 语法是： **$((表达式))** ，此处表达式中的 "*" 不需要转义符号 "\" 。

## 2、关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

|运算符|说明|举例|
| :----: | :-------------------------------------------------: | :----------------: |
|-eq|检测两个数是否相等，相等返回 true。|[ $a -eq$b ] 返回 false。|
|-ne|检测两个数是否不相等，不相等返回 true。|[ $a -ne$b ] 返回 true。|
|-gt|检测左边的数是否大于右边的，如果是，则返回 true。|[ $a -gt$b ] 返回 false。|
|-lt|检测左边的数是否小于右边的，如果是，则返回 true。|[ $a -lt$b ] 返回 true。|
|-ge|检测左边的数是否大于等于右边的,如果是,则返回 true。|[ $a -ge$b ] 返回 false。|
|-le|检测左边的数是否小于等于右边的,如果是,则返回 true。|[ $a -le$b ] 返回 true。|

## 3、布尔运算符

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

|运算符|说明|举例|
| :----: | :---------------------------------------: | :------------------------: |
|!|非运算，表达式为 true 则返回 false，|[ ! false ] 返回 true。|
|-o|或运算，有一个表达式为 true 则返回 true。|[ $a -lt 20 -o$b -gt 100 ] 返回 true。|
|-a|与运算，两个表达式都为 true 才返回 true。|[ $a -lt 20 -a$b -gt 100 ] 返回 false。|

## 4、逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

|运算符|说明|
| :----: | :--------: |
|&&|逻辑的 AND|
|\|\||逻辑的 OR|

## 5、字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

|运算符|说明|举例|
| :----: | :------------------------------------------: | :---------------------: |
|=|检测两个字符串是否相等，相等返回 true。|[ $a =$b ] 返回 false。|
|!=|检测两个字符串是否不相等，不相等返回 true。|[ $a !=$b ] 返回 true。|
|-z|检测字符串长度是否为0，为0返回 true。|[ -z $a ] 返回 false。|
|-n|检测字符串长度是否不为 0，不为 0 返回 true。|[ -n "$a" ] 返回 true。|
|$|检测字符串是否不为空，不为空返回 true。|[ $a ] 返回 true。|

## 6、文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：

|操作符|说明|
| :-----: | :-------------------------------------------------------------------------: |
|-b file|检测文件是否是块设备文件，如果是，则返回 true。|
|-c file|检测文件是否是字符设备文件，如果是，则返回 true。|
|-d file|检测文件是否是目录，如果是，则返回 true。|
|-e file|检测文件是否存在，如果是，则返回 true。|
|-f file|检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。|
|-g file|检测文件是否设置了 SGID 位，如果是，则返回 true。|
|-k file|检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|
|-p file|检测文件是否是有名管道，如果是，则返回 true。|
|-u file|检测文件是否设置了 SUID 位，如果是，则返回 true。|
|-r file|检测文件是否可读，如果是，则返回 true。|

其他检查符：

-  **-S**: 判断某文件是否 socket。
-  **-L**: 检测文件是否存在并且是一个符号链接。

---

# 二、字符串处理

## 1、字符串切片

```shell
＄{变量：偏移量：截取长度｝

--------------------------example
[192.168.2.230] - root@ubuntu20.04.5-template:/ root
$ MYPATH=' /usr/bin/wget'

[192.168.2.230］ - root@ubuntu20.04.5-template:/root
$ echo ${MYPATH: 4:4}
/bin     			  #其会左向右从第四位向后取四位（字符串第一位为0）

[192.168.2.230] - root@ubuntu20.04.5-template:/ root
$ echo ${MYPATH: -4}  #这会右向左从末尾向前取四位，「-4和冒号之间要有一个空格」

```

## 2、基于模式取子串

```shell
${var#*word}
其中word可以是指定的任意字符，自左而右，删除字符串开头至第一次出现word字符之间的所有字符。

${var##*word}
其中word可以是指定的任意字符，自左而右，删除字符串开头至最后一次出现word字符之间的所有字符。

${var%sword*}
其中word可以是指定的任意字符，自右而左，删除字符串尾部至第一次出现word字符之间的所有字符。

${var%%sword*}
其中word可以是指定的任意字符，自右而左，删除字符串尾部至最后一次出现word字符之间的所有字符
```

## 3、查找删除

```shell
${var/匹配文本｝
删除第一次匹配到的内容

${var//pattern｝
删除所有匹配到的内容

${var/#pattern｝
删除行首匹配到的内容

${var/%pattern｝
删除行尾匹配到的内容
```

## 4、查找替换

```shell
${var/匹配文本/替换文本｝
替换第一次匹配到的内容

${var//匹配文本/替换文本｝
替换所有匹配到的内容

${var/#匹配文本/替换文本｝
行首匹配时替换行首

${var/%匹配文本/替换文本｝
行尾匹配时替换行尾
```

---

# 三、条件判断语法格式

- test条件表达式
- [ 条件表达式 ]
- [[ 条件表达式 ]]

**特别说明**：

1）[ 亲亲，我两边都有空格，不空会被打死的喔～ ]

2）[[ 亲亲，我两边都有空格，不空会被打死的喔～ ]]

3）更多判断，`man test`查看，许多的参数都可用来进行条件判断

## [] 和 [[]] 的区别：

### `[]` （test 命令）

`[]` 是传统的测试条件的命令，也称为 `test` 命令。这种语法适用于POSIX标准的Shell，包括sh和bash。

- **基本语法**：

  ```sh
  [ condition ]
  ```
- **用法和特点**：

  - 条件需要用空格分隔。
  - 只支持基本的逻辑和比较操作。
  - 适用于大多数Unix系统。
- **示例**：

  ```sh
  if [ "$a" -eq "$b" ]; then
    echo "a 等于 b"
  fi
  ```

### `[[]]` （扩展测试命令）

`[[]]` 是Bash特有的扩展测试命令，提供了更强大的功能和更简洁的语法。

- **基本语法**：

  ```sh
  [[ condition ]]
  ```
- **用法和特点**：

  - 支持更复杂的条件测试，例如模式匹配（通配符）。
  - 可以直接使用逻辑运算符 `&&` 和 `||` 进行复合条件判断。
  - 允许在字符串比较中使用 `=~` 操作符进行正则表达式匹配。
  - 不需要对条件中的变量进行双引号引用，因为它可以正确处理空字符串和带空格的字符串。
- **示例**：

  ```sh
  if [[ $a == $b ]]; then
    echo "a 等于 b"
  fi
  
  if [[ $a =~ ^[0-9]+$ ]]; then
    echo "a 是一个数字"
  fi
  ```

### 详细对比

- **字符串比较**：

  - `[]` 使用 `=` 进行字符串比较，通常需要使用双引号。
    ```sh
    [ "$a" = "$b" ]
    ```
  - `[[]]` 使用 `==` 进行字符串比较，不需要双引号。
    ```sh
    [[ $a == $b ]]
    ```
- **逻辑运算**：

  - `[]` 需要使用 `-a` (AND) 和 `-o` (OR)。

    ```sh
    [ "$a" -eq "$b" -a "$c" -eq "$d" ]
    ```
  - `[[]]` 可以使用 `&&` 和 `||`。

    ```sh
    [[ $a -eq $b && $c -eq $d ]]
    ```
- **正则表达式匹配**：

  - `[]` 不支持直接的正则表达式匹配。
  - `[[]]` 支持 `=~` 操作符。

    ```sh
    [[ $a =~ ^[0-9]+$ ]]
    ```
- **模式匹配**：

  - `[]` 不支持模式匹配。
  - `[[]]` 支持模式匹配。

    ```sh
    [[ $a == *.txt ]]
    ```

### 总结

- 使用 `[]` 更适合于需要兼容POSIX标准的脚本和基本条件测试。
- 使用 `[[]]` 提供了更强大和简洁的语法，适合于需要进行复杂条件判断的Bash脚本。

在实际编程中，建议在Bash脚本中尽量使用 `[[]]`，除非需要兼容性考虑，这样可以充分利用其扩展功能和更清晰的语法。

---

# 四、流程控制

## if else 语法格式

```shell
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
```

## if else-if else 语法格式

```zsh
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt，其他用法请参照**运算符**。

```
if [ "$a" -gt "$b" ]; then
    ...
fi
```

如果使用((...)) 作为判断语句，就可以使用类c风格判断，大于和小于可以直接使用 > 和 <。

```
if (( a > b )); then
    ...
fi
```

## for循环

```zsh
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

举个栗子🌰

```zsh
#!/bin/bash

for str in This is a string
do
    echo $str
done
```

输出结果：

```
This
is
a
string
```

> 要打印1 -> 10的数字，可以用以下格式

```zsh
#!/bin/zsh

for i in {1..10}
do 
    echo "$i"
done
```

> 或者以下类c风格

```zsh
#!/bin/zsh

for ((i=1; i<11; i++))
do 
    echo "$i"
done
```

## while循环

```zsh
while condition
do
    command
done
```

举个栗子🌰

```zsh
#!/bin/bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done
```

## 无限循环

无限循环语法格式：

```
while :
do
    command
done
```

或者

```
while true
do
    command
done
```

或者

```
for (( ; ; ))
```

---

## until 循环

until 循环执行一系列命令直至条件为 true 时停止。

until 循环与 while 循环在处理方式上刚好相反。

一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。

until 语法格式:

```
until condition
do
    command
done
```

condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。

---

# 五、获取当前日期以及时间

在 Unix 或 Linux 系统中，`date` 命令用于显示或设置系统日期和时间。`date` 命令可以接受多种格式化字符串来指定输出的格式。

命令 `date +%M` 会返回当前时间中的“分钟”部分。例如，如果当前时间是 14:35，那么运行 `date +%M` 会输出 `35`。

下面是一些常用的 `date` 格式化字符串及其含义：

- `%Y`：四位数的年份（例如，2023）
- `%m`：两位数的月份（例如，05 表示五月）
- `%d`：两位数的日期（例如，17）
- `%D`：格式化日期（例如2024年五月17日，其会输出05/17/24）
- `%H`：两位数的小时（24 小时制，例如，14 表示下午 2 点）
- `%M`：两位数的分钟（例如，35）
- `%S`：两位数的秒（例如，45）
- `%s`：当前时间的Unix时间戳（也称为纪元时间）。Unix时间戳是从1970年1月1日00:00:00 UTC（协调世界时）开始经过的秒数。

所以，`date +%M` 的输出仅仅是当前时间的分钟部分。

---

# 六、传递参数

## 特殊参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，**n** 代表一个数字，**1** 为执行脚本的第一个参数，**2** 为执行脚本的第二个参数。

例如可以使用 $1、$2 等来引用传递给脚本的参数，其中$1表示第一个参数，$2 表示第二个参数，依此类推。

在`#!/bin/zsh`脚本中，`$#`和`$0`是特定的shell变量，用于脚本参数处理和信息获取。让我们详细解释它们的含义：

- `$#` 用于表示传递给脚本的参数数量。
- `$0` 为执行的文件名（包含文件路径），即脚本自身的文件名。
- `$?`显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
- `$-`显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。
- `$!`后台运行的最后一个进程的ID号
- `$$`脚本运行的当前进程ID号
- `$*`以一个单字符串显示所有向脚本传递的参数。
- `$@`与$*相同，但是使用时加引号，并在引号中返回每个参数。

## $# 的含义

`$#` 代表传递给脚本的参数数量。在脚本开头，有以下代码：

```zsh
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi
```

这段代码的意思是：检查传递给脚本的参数数量是否不等于1。如果不是1个参数（即传递了0个参数或者多于1个参数），则输出使用说明并退出脚本。换句话说，`$#`用于确保脚本接收正好一个参数。

## $0 的含义

`$0` 代表脚本自身的文件名（包含文件路径）。在脚本中同样的代码：

```zsh
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi
```

在这个例子中，`$0`表示脚本文件的名称。假设脚本的文件名是`rename_files.sh`，那么当你执行这个脚本时，`$0`就会被替换为`rename_files.sh`。因此，输出的使用说明会是：

```
Usage: rename_files.sh <directory>
```

‍
