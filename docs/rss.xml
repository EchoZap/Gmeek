<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>罗华东's Blog</title><link>https://echozap.github.io</link><description>接受过《中华人民共和国义务教育法》规定的完整「九年义务教育」，如今也是个「正儿八经」的「文化人」，目前的物理活动范围主要在「某东亚大国」。</description><copyright>罗华东's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/avatar.avg</url><title>avatar</title><link>https://echozap.github.io</link></image><lastBuildDate>Sun, 11 Aug 2024 07:41:37 +0000</lastBuildDate><managingEditor>罗华东's Blog</managingEditor><ttl>60</ttl><webMaster>罗华东's Blog</webMaster><item><title>「OrbStack」Mac 系统中一个更快的 Docker 可视化工具，可完全替代 Docker Desktop</title><link>https://echozap.github.io/post/%E3%80%8COrbStack%E3%80%8DMac%20-xi-tong-zhong-yi-ge-geng-kuai-de-%20Docker%20-ke-shi-hua-gong-ju-%EF%BC%8C-ke-wan-quan-ti-dai-%20Docker%20Desktop.html</link><description>&#13;
我之前用的是 Docker Desktop，每次准备启动容器的时候，我都会把能关的应用都关闭，省的电脑卡， Docker Desktop 确实有点儿耗性能。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8COrbStack%E3%80%8DMac%20-xi-tong-zhong-yi-ge-geng-kuai-de-%20Docker%20-ke-shi-hua-gong-ju-%EF%BC%8C-ke-wan-quan-ti-dai-%20Docker%20Desktop.html</guid><pubDate>Thu, 08 Aug 2024 13:53:24 +0000</pubDate></item><item><title>Docker常用命令</title><link>https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</link><description>![DockerCheatSheet.png](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/DockerCheatSheet.png)&#13;
&#13;
# 列出所有已下载镜像&#13;
```shell&#13;
❯ docker images&#13;
REPOSITORY        TAG       IMAGE ID       CREATED         SIZE&#13;
ubuntu            latest    ffb64c9b7e8b   3 weeks ago     101MB&#13;
b3log/siyuan      latest    caf98195a3c3   3 weeks ago     220MB&#13;
soulteary/flare   latest    843d799dc8b2   2 months ago    12.8MB&#13;
hello-world       latest    ee301c921b8a   14 months ago   9.14kB&#13;
``` &#13;
&#13;
# 列出当前所有容器&#13;
```shell&#13;
❯ docker ps -a&#13;
CONTAINER ID   IMAGE     COMMAND                   CREATED              STATUS      &#13;
2295f62c584b   ubuntu    '/bin/sh -c 'while t…'   1 minute ago   Up About a minute&#13;
526462e8b92d   ubuntu    '/bin/bash'               44 minutes ago       Exited (0) &#13;
``` &#13;
&#13;
输出详情介绍：&#13;
- **CONTAINER ID:**  容器 ID。</description><guid isPermaLink="true">https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</guid><pubDate>Sat, 03 Aug 2024 07:08:59 +0000</pubDate></item><item><title>ffmpeg常用用法</title><link>https://echozap.github.io/post/ffmpeg-chang-yong-yong-fa.html</link><description># 不改变原视频码率裁剪&#13;
### 废话少说，直接举栗🌰&#13;
1.从 `1时15分25秒` 开始裁剪到视频结束： &#13;
```shell&#13;
ffmpeg -i input.mp4 -ss 01:15:25 -c copy output.mp4&#13;
``` &#13;
&#13;
2.从 `视频开始到15分5秒` ：&#13;
```shell&#13;
ffmpeg -i input.mp4 -to 00:15:05 -c copy output.mp4&#13;
```  &#13;
&#13;
3.从 `15分25秒` 到  `1时15分25秒` ：&#13;
```shell&#13;
ffmpeg -i input.mp4 -ss 15:25 -to 01:15:25 -c copy output.mp4&#13;
``` &#13;
  &#13;
`-i` 指定输入视频路径，`input.mp4`是要裁剪的视频文件的路径， `-ss` 裁剪视频起始时间，`-to` 裁剪视频结束时间，`-c copy` 在裁剪时不改变视频编码，从而保持原始视频码率， `output.mp4` 为裁剪后的视频文件。</description><guid isPermaLink="true">https://echozap.github.io/post/ffmpeg-chang-yong-yong-fa.html</guid><pubDate>Sat, 03 Aug 2024 06:54:09 +0000</pubDate></item><item><title>「Gmeek进阶」强调关键信息使用</title><link>https://echozap.github.io/post/%E3%80%8CGmeek-jin-jie-%E3%80%8D-qiang-diao-guan-jian-xin-xi-shi-yong.html</link><description>Github的语法里面有5中警报强调信息，分别是`NOTE`、 `TIP`、 `IMPORTANT`、 `WARNING`、 `CAUTION` 。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CGmeek-jin-jie-%E3%80%8D-qiang-diao-guan-jian-xin-xi-shi-yong.html</guid><pubDate>Fri, 02 Aug 2024 08:15:11 +0000</pubDate></item><item><title>macOS电池管理脚本</title><link>https://echozap.github.io/post/macOS-dian-chi-guan-li-jiao-ben.html</link><description>将以下内容保存为 `power_manager.sh` 并放入系统环境变量的路径中，接下来可通过 `nohub /path/power_manager.sh &amp;` 来实现后台运行&#13;
&#13;
```&#13;
#!/bin/zsh&#13;
&#13;
# 关闭休眠&#13;
disable_sleep() {&#13;
    sudo pmset -b sleep 0&#13;
    sudo pmset -b disablesleep 1&#13;
}&#13;
&#13;
# 启用休眠&#13;
enable_sleep() {&#13;
    sudo pmset -b sleep 5&#13;
    sudo pmset -b disablesleep 0&#13;
}&#13;
&#13;
while true; do&#13;
&#13;
    LOG_FILE='/Users/a1/power_manager.log'&#13;
&#13;
    # 获取电脑盖子状态&#13;
    lid_state=$(ioreg -r -k AppleClamshellState -d 4 | grep AppleClamshellState | head -1 | awk '{print $NF}')&#13;
&#13;
    # 获取电源连接状态&#13;
    ac_state=$(pmset -g batt | head -1)&#13;
&#13;
    if [[ $lid_state == 'Yes' ]]; then&#13;
    # 合盖状态&#13;
        if [[ $ac_state =~ 'AC' ]]; then&#13;
            # 连接电源，关闭休眠并立即保持系统唤醒&#13;
            disable_sleep&#13;
        else&#13;
            # 未连接电源，开启休眠并立即进入休眠&#13;
            enable_sleep&#13;
            pmset sleepnow&#13;
        fi&#13;
    else&#13;
    # 开盖状态&#13;
        if [[ $ac_state =~ 'AC' ]]; then&#13;
            # 连接电源，关闭休眠并保持系统唤醒&#13;
            disable_sleep&#13;
        else&#13;
            # 未连接电源，开启休眠但不立即进入休眠&#13;
            enable_sleep&#13;
        fi&#13;
    fi&#13;
    sleep 5&#13;
done&#13;
```。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-dian-chi-guan-li-jiao-ben.html</guid><pubDate>Fri, 02 Aug 2024 06:08:01 +0000</pubDate></item><item><title>python虚拟环境</title><link>https://echozap.github.io/post/python-xu-ni-huan-jing.html</link><description>*在虚拟环境中，pip 和 pip3 通常会指向同一个 Python 版本的包管理器。</description><guid isPermaLink="true">https://echozap.github.io/post/python-xu-ni-huan-jing.html</guid><pubDate>Mon, 29 Jul 2024 12:48:40 +0000</pubDate></item><item><title>macOS查看或切换当前python解释器</title><link>https://echozap.github.io/post/macOS-cha-kan-huo-qie-huan-dang-qian-python-jie-shi-qi.html</link><description># 查看系统中所有安装的 Python 解释器&#13;
```&#13;
which -a python python3&#13;
```&#13;
这会列出系统路径中找到的 python 和 python3 解释器的位置:&#13;
```&#13;
❯ which -a python python3&#13;
&#13;
python not found&#13;
/usr/bin/python3&#13;
/opt/homebrew/bin/python3&#13;
```&#13;
`-a` 选项确保显示所有匹配的路径，而不仅仅是第一个。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-cha-kan-huo-qie-huan-dang-qian-python-jie-shi-qi.html</guid><pubDate>Mon, 29 Jul 2024 11:44:59 +0000</pubDate></item><item><title>「各种摸不着头脑」意外修改PATH(环境变量)</title><link>https://echozap.github.io/post/%E3%80%8C-ge-zhong-mo-bu-zhao-tou-nao-%E3%80%8D-yi-wai-xiu-gai-PATH%28-huan-jing-bian-liang-%29.html</link><description># 1. **检查sudo是否已经安装**&#13;
&#13;
确保 **sudo** 已经正确地安装在你的系统中。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8C-ge-zhong-mo-bu-zhao-tou-nao-%E3%80%8D-yi-wai-xiu-gai-PATH%28-huan-jing-bian-liang-%29.html</guid><pubDate>Sun, 28 Jul 2024 09:55:30 +0000</pubDate></item><item><title>Linux查看或修改主机名</title><link>https://echozap.github.io/post/Linux-cha-kan-huo-xiu-gai-zhu-ji-ming.html</link><description># 1查看当前主机名&#13;
&#13;
```plain&#13;
hostname&#13;
```&#13;
&#13;
这将会显示当前的主机名，或者&#13;
&#13;
```zsh&#13;
cat /etc/hostname&#13;
```&#13;
  &#13;
&#13;
# 2修改主机名&#13;
&#13;
使用以下命令设置新主机名&#13;
&#13;
```zsh&#13;
sudo hostnamectl set-hostname &lt;new_hostname&gt;&#13;
```&#13;
&#13;
之后在文件中找到包含旧主机名的行，并将其替换为新主机名。</description><guid isPermaLink="true">https://echozap.github.io/post/Linux-cha-kan-huo-xiu-gai-zhu-ji-ming.html</guid><pubDate>Sun, 28 Jul 2024 09:46:14 +0000</pubDate></item><item><title>「国内解决方法」linux安装docker</title><link>https://echozap.github.io/post/%E3%80%8C-guo-nei-jie-jue-fang-fa-%E3%80%8Dlinux-an-zhuang-docker.html</link><description># 1.安装Docker&#13;
&#13;
一键安装命令&#13;
&#13;
```&#13;
sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun&#13;
```&#13;
&#13;
&gt; 备用（如果Github访问不了，可以使用Gitee的链接）&lt;br&gt;&#13;
&#13;
```&#13;
sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun&#13;
```&#13;
&#13;
启动docker&#13;
&#13;
```&#13;
sudo service docker start&#13;
```&#13;
&#13;
# 2.镜像拉取&#13;
&#13;
```zsh&#13;
bash -c '$(curl -sSLf https://xy.ggbond.org/xy/docker_pull.sh)' -s 完整镜像名&#13;
```&#13;
&#13;
如有额外需求，以下是`docker_pull.sh`：&#13;
&#13;
```zsh&#13;
#!/bin/bash&#13;
# shellcheck shell=bash&#13;
# shellcheck disable=SC2086&#13;
&#13;
PATH=${PATH}:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin:/opt/homebrew/bin&#13;
export PATH&#13;
&#13;
Blue='\033[1;34m'&#13;
Green='\033[1;32m'&#13;
Red='\033[1;31m'&#13;
Yellow='\033[1;33m'&#13;
NC='\033[0m'&#13;
INFO='[${Green}INFO${NC}]'&#13;
ERROR='[${Red}ERROR${NC}]'&#13;
WARN='[${Yellow}WARN${NC}]'&#13;
&#13;
function INFO() {&#13;
    echo -e '${INFO} ${1}'&#13;
}&#13;
function ERROR() {&#13;
    echo -e '${ERROR} ${1}'&#13;
}&#13;
function WARN() {&#13;
    echo -e '${WARN} ${1}'&#13;
}&#13;
&#13;
function docker_pull() {&#13;
    #[ -z '${config_dir}' ] &amp;&amp; get_config_path&#13;
    local config_dir=${2:-'/etc/xiaoya'}&#13;
    mkdir -p '${config_dir}'&#13;
    local mirrors=('docker.io' 'docker.fxxk.dedyn.io' 'docker.m.daocloud.io' 'docker.adysec.com' 'registry-docker-hub-latest-9vqc.onrender.com' 'docker.chenby.cn' 'dockerproxy.com' 'hub.uuuadc.top' 'docker.jsdelivr.fyi' 'docker.registry.cyou' 'dockerhub.anzu.vip')&#13;
    if [ -s '${config_dir}/docker_mirrors.txt' ]; then&#13;
        mirrors=()&#13;
        while IFS= read -r line; do&#13;
            mirrors+=('$line')&#13;
        done &lt; '${config_dir}/docker_mirrors.txt'&#13;
    else&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            printf '%s\n' '$mirror' &gt;&gt; '${config_dir}/docker_mirrors.txt'&#13;
        done&#13;
    fi&#13;
    if command -v timeout &gt; /dev/null 2&gt;&amp;1;then&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            INFO '正在测试${mirror}代理点的连接性……'&#13;
            if timeout 30 docker pull '${mirror}/library/hello-world:latest'; then&#13;
                INFO '${mirror}代理点连通性测试正常！正在为您下载镜像……'&#13;
                for i in {1..2}; do&#13;
                    if timeout 300 docker pull '${mirror}/${1}'; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        break;&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                done&#13;
                if [[ '${mirror}' == 'docker.io' ]];then&#13;
                    docker rmi 'library/hello-world:latest'&#13;
                    [ -n '$(docker images -q '${1}')' ] &amp;&amp; return 0&#13;
                else&#13;
                    docker rmi '${mirror}/library/hello-world:latest'&#13;
                    [ -n '$(docker images -q '${mirror}/${1}')' ] &amp;&amp; break&#13;
                fi&#13;
            fi&#13;
        done&#13;
    else&#13;
        timeout=20&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            INFO '正在测试${mirror}代理点的连接性……'       &#13;
            docker pull '${mirror}/library/hello-world:latest' || true &amp;&#13;
            pid=$!&#13;
            count=0&#13;
            while kill -0 $pid 2&gt;/dev/null; do&#13;
                sleep 5&#13;
                count=$((count+5))&#13;
                if [ $count -ge $timeout ]; then&#13;
                    echo 'Command timed out'&#13;
                    kill $pid&#13;
                    break&#13;
                fi&#13;
            done&#13;
&#13;
            if [ $? -eq 0 ]; then&#13;
                INFO '${mirror}代理点连通性测试正常！正在为您下载镜像……'&#13;
                timeout=200&#13;
                for i in {1..2}; do&#13;
                    docker pull '${mirror}/${1}' || true &amp;&#13;
                    pid=$!&#13;
                    count=0&#13;
                    while kill -0 $pid 2&gt;/dev/null; do&#13;
                        sleep 5&#13;
                        count=$((count+5))&#13;
                        if [ $count -ge $timeout ]; then&#13;
                            echo 'Command timed out'&#13;
                            kill $pid&#13;
                            break&#13;
                        fi&#13;
                    done&#13;
                done&#13;
                if [[ '${mirror}' == 'docker.io' ]];then&#13;
                    docker rmi 'library/hello-world:latest'&#13;
                    if [ -n '$(docker images -q '${1}')' ]; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        return 0&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                else&#13;
                    docker rmi '${mirror}/library/hello-world:latest'&#13;
                    if [ -n '$(docker images -q '${mirror}/${1}')' ]; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        break&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                fi&#13;
            fi&#13;
        done&#13;
    fi&#13;
&#13;
    if [ -n '$(docker images -q '${mirror}/${1}')' ]; then&#13;
        docker tag '${mirror}/${1}' '${1}'&#13;
        docker rmi '${mirror}/${1}'&#13;
        return 0&#13;
    else&#13;
        ERROR '已尝试所有镜像代理拉取失败，程序退出，请检查网络后再试！'&#13;
        exit 1       &#13;
    fi&#13;
}&#13;
&#13;
if [ -n '$1' ];then&#13;
    docker_pull $1 $2&#13;
else&#13;
    while :; do&#13;
        read -erp '请输入您要拉取镜像的完整名字（示例：ailg/alist:latest）：' pull_img&#13;
        [ -n '${pull_img}' ] &amp;&amp; break&#13;
    done&#13;
    docker_pull '${pull_img}'&#13;
fi&#13;
```。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8C-guo-nei-jie-jue-fang-fa-%E3%80%8Dlinux-an-zhuang-docker.html</guid><pubDate>Sun, 28 Jul 2024 09:34:41 +0000</pubDate></item><item><title>mac使用主机名代替IP地址进行ssh连接</title><link>https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</link><description># 1编辑本地SSH配置文件&#13;
&#13;
1. **编辑本地 SSH 配置文件**：首先，你需要编辑本地 SSH 配置文件，可以使用任何文本编辑器打开 `~/.ssh/config` 文件。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</guid><pubDate>Sun, 28 Jul 2024 09:24:43 +0000</pubDate></item><item><title>Linux用户与用户组的创建、切换及删除</title><link>https://echozap.github.io/post/Linux-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</link><description># 1创建新用户&#13;
&#13;
1. 以root用户身份登录到Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/Linux-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</guid><pubDate>Sun, 28 Jul 2024 09:15:25 +0000</pubDate></item><item><title>SSH 远程登录以及 SFTP 文件传输</title><link>https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</link><description>**SSH 默认端口号是22.**&#13;
&#13;
# SSH 远程登录主机&#13;
&#13;
```shell&#13;
ssh username@hostname&#13;
```&#13;
&#13;
其中，`username`是用户名，`hostname` 是主机名或IP 地址。</description><guid isPermaLink="true">https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</guid><pubDate>Sun, 28 Jul 2024 09:07:40 +0000</pubDate></item><item><title>Mac以指纹授权sudo指令的</title><link>https://echozap.github.io/post/Mac-yi-zhi-wen-shou-quan-sudo-zhi-ling-de.html</link><description>使用以下命令打开；&#13;
&#13;
```zsh&#13;
sudo vim /etc/pam.d/sudo&#13;
```&#13;
&#13;
出现以下内容：&#13;
&#13;
```zsh&#13;
  1 # sudo: auth account password session&#13;
  2 auth       include        sudo_local&#13;
  3 auth       sufficient     pam_smartcard.so&#13;
  4 auth       required       pam_opendirectory.so&#13;
  5 account    required       pam_permit.so&#13;
  6 password   required       pam_deny.so&#13;
  7 session    required       pam_permit.so&#13;
```&#13;
&#13;
&#13;
将下面这一行&#13;
&#13;
```plain&#13;
auth sufficient pam_smartcard.so&#13;
```&#13;
&#13;
修改为&#13;
&#13;
```plain&#13;
auth sufficient pam_tid.so&#13;
```&#13;
&#13;
保存并退出即可。</description><guid isPermaLink="true">https://echozap.github.io/post/Mac-yi-zhi-wen-shou-quan-sudo-zhi-ling-de.html</guid><pubDate>Sun, 28 Jul 2024 09:04:06 +0000</pubDate></item><item><title>mac合盖不休眠、安装包损坏解决办法</title><link>https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</link><description># 'app已损坏，无法打开'问题解决方法&#13;
&#13;
```shell&#13;
sudo xattr -rd com.apple.quarantine &lt;your_app_path&gt;&#13;
```&#13;
&#13;
将`your_app_path`替换成app路径，可以直接将应用程序里的app图标拖到终端窗口的这条命令里，按回车键执行。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</guid><pubDate>Sun, 28 Jul 2024 08:49:50 +0000</pubDate></item><item><title>sdcc工程创建模版程序</title><link>https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</link><description>## 1.程序构建&#13;
&#13;
新建一个txt文件并将以下代码复制到`xxx.txt`，之后将`xxx.txt（例如sdccpj.txt）`后缀名修改为`.sh（例如sdccpj.sh）`或者直接去掉后缀名只保留文件名（这在类linux系统中就是可执行程序）`sdccpj`。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</guid><pubDate>Sun, 28 Jul 2024 06:45:46 +0000</pubDate></item><item><title>Makefile</title><link>https://echozap.github.io/post/Makefile.html</link><description>## 1.规则&#13;
&#13;
&gt; Makefile的框架是由规则构成的。</description><guid isPermaLink="true">https://echozap.github.io/post/Makefile.html</guid><pubDate>Sun, 28 Jul 2024 06:36:41 +0000</pubDate></item><item><title>静态库与动态库</title><link>https://echozap.github.io/post/jing-tai-ku-yu-dong-tai-ku.html</link><description>不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。</description><guid isPermaLink="true">https://echozap.github.io/post/jing-tai-ku-yu-dong-tai-ku.html</guid><pubDate>Sun, 28 Jul 2024 03:36:47 +0000</pubDate></item><item><title>SSH 免密登录</title><link>https://echozap.github.io/post/SSH%20-mian-mi-deng-lu.html</link><description># 1创建密钥&#13;
&#13;
在本地主机终端输入&#13;
&#13;
```shell&#13;
ssh-keygen&#13;
```&#13;
&#13;
之后一路回车，不出意外的话，你将看到以下内容&#13;
&#13;
![img](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/ssh-keygen.png)&#13;
&#13;
恭喜，你已经完成第一步！&#13;
&#13;
---&#13;
&#13;
# 2检查密钥是否创建成功&#13;
&#13;
在终端输入&#13;
&#13;
```shell&#13;
ls .ssh&#13;
```&#13;
&#13;
看到以下内容&#13;
&#13;
![img](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/ls_.ssh.png)&#13;
&#13;
看到其中有`id_ed25519`(私钥))**其中的ed25519在不同设备可能会有不同，有的可能是id_rsa**、`id_ed25519.pub`(公钥)两个文件，恭喜，你已经完成第二步了，离成功更近了！&#13;
&#13;
---&#13;
&#13;
# 3将公钥复制到远程主机&#13;
&#13;
在终端键入&#13;
&#13;
```shell&#13;
ssh-copy-id -i &lt;~/.ssh/id_ed25519.pub&gt; &lt;username&gt;@&lt;remote_ip&gt;&#13;
```&#13;
&#13;
其中的`&lt;~/.ssh/id_ed25519.pub&gt;` 是公钥所处的路径，`&lt;username&gt;`是用户名，`&lt;remote_ip&gt;`是主机名或IP 地址。</description><guid isPermaLink="true">https://echozap.github.io/post/SSH%20-mian-mi-deng-lu.html</guid><pubDate>Sun, 28 Jul 2024 03:19:49 +0000</pubDate></item><item><title>Typora土图床自动上传脚本</title><link>https://echozap.github.io/post/Typora-tu-tu-chuang-zi-dong-shang-chuan-jiao-ben.html</link><description>&gt; typroa的图片上传脚本，针对[Telegraph-Image](https://github.com/cf-pages/Telegraph-Image)项目，适用于macOS和Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/Typora-tu-tu-chuang-zi-dong-shang-chuan-jiao-ben.html</guid><pubDate>Sun, 28 Jul 2024 03:03:04 +0000</pubDate></item><item><title>sdcc编译与链接</title><link>https://echozap.github.io/post/sdcc-bian-yi-yu-lian-jie.html</link><description>## 1.编译源文件&#13;
&#13;
首先，你需要编译你的源文件（例如 `main.c`）以生成目标文件（.rel）。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc-bian-yi-yu-lian-jie.html</guid><pubDate>Sat, 27 Jul 2024 07:37:39 +0000</pubDate></item><item><title>shell 编程</title><link>https://echozap.github.io/post/shell%20-bian-cheng.html</link><description># 一、运算符&#13;
&#13;
## 1、算术运算符&#13;
&#13;
下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：&#13;
&#13;
|运算符|说明|举例|&#13;
| :----: | :-------------------------------------------: | :------------------------: |&#13;
|+|加法|`expr $a + $b` 结果为 30。</description><guid isPermaLink="true">https://echozap.github.io/post/shell%20-bian-cheng.html</guid><pubDate>Sat, 27 Jul 2024 07:33:17 +0000</pubDate></item><item><title>vscode搭建用于8051单片机的sdcc环境</title><link>https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</link><description>## 查找sdcc以及8051头文件位置&#13;
&#13;
```shell&#13;
❯ which sdcc&#13;
&#13;
/opt/homebrew/bin//sdcc&#13;
```&#13;
&#13;
这将列出sdcc的安装位置。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</guid><pubDate>Sat, 27 Jul 2024 07:26:20 +0000</pubDate></item><item><title>vscode磨砂效果配置</title><link>https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</link><description>## 1.安装插件&#13;
&#13;
[[Apc Customize UI++ ](https://marketplace.visualstudio.com/items?itemName=drcika.apc-extension)](https://marketplace.visualstudio.com/items?itemName=drcika.apc-extension)&#13;
&#13;
## 2.下载图片&#13;
&#13;
![Noisefigure](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/noisefigure.png)&#13;
&#13;
## 3.配置文件&#13;
&#13;
在vscode的`.settings.json`中键入以下配置，**注意：** 将`/Users/einson/Pictures/vscbg/Noisefigure.png`修改为自己的文件路径&#13;
&#13;
```json&#13;
'apc.stylesheet': {&#13;
    'body': {&#13;
        'background-image': 'url(/Users/einson/Pictures/vscbg/Noisefigure.png), linear-gradient(to top,rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.2))',&#13;
        'background-size': 'cover',&#13;
        'background-blend-mode': 'multiply',&#13;
        'background-repeat': 'no-repeat',&#13;
        'opacity': 0.89&#13;
    },&#13;
}&#13;
```&#13;
&#13;
## 4.意想不到的问题(无问题可忽略)&#13;
&#13;
有可能最终配置效果不尽人意，所以在这里可以安装一款字体(可选)，在vscode的`.settings.json`键入以下内容。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</guid><pubDate>Sat, 27 Jul 2024 01:44:00 +0000</pubDate></item><item><title>PlatformIO烧录失败解决方法</title><link>https://echozap.github.io/post/PlatformIO-shao-lu-shi-bai-jie-jue-fang-fa.html</link><description>## 遭遇问题&#13;
​***platformIO一直卡在烧录程序中，导致开发版一直处于断电状态***&#13;
![问题](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/question.png)&#13;
&#13;
&#13;
## 解决方法&#13;
&#13;
将main.py里的这一行注释即可&#13;
![解决1](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/method1.png)&#13;
&#13;
&#13;
该文件在以下路径&#13;
`~/.platformio/intel_mcs51/builder/main.py`&#13;
![解决2](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/method2.png)&#13;
。</description><guid isPermaLink="true">https://echozap.github.io/post/PlatformIO-shao-lu-shi-bai-jie-jue-fang-fa.html</guid><pubDate>Sat, 22 Jun 2024 07:16:18 +0000</pubDate></item></channel></rss>